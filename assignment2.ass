      .makeexe   // Assignment #2.1, 24 March 2014, Oliver Chang
      jump main  // An Interrupt-based Input System
//=============================================================================
//============================= DATA STRUCTURES ===============================
//=============================================================================
// Setup an array where we can store pointers to our interrupt handling funcs.
// There are only 14 interrupts in our computer, but we round up.
interrupt_vector: .space 16

// The software queue where we store the characters of a single line of input.
// The number designated here specifies words. There are four chars per word.
// Thus, this includes space for 128*4 = 512 characters, a sane limit.
character_buffer: .space 128

// A reserved word of memory where for use with the $TERMINC & PERI commands.
// TODO: embiggen
character_scratch: .space 1

// The next available index in character_buffer that's available for the op.
writeptr: .data 0
readptr: .data 0

// Control structures for reading and writing out.
// Assume that we only want to collect a character at a time since that is when
// the keyboard interrupt is triggered.
// TODO: embiggen
control_in: .data $terminc, 1, 0
// Used solely for outputting error messages and for practice.
control_out: .data $termoutc, 0, 0

// Error Codes
// code -2: problem reading the control struct
code2: .string "ERR_READ_PARAMS"
code2_len: .data 15
// code -5: problem storing the characters in memory
code5: .string "ERR_MEMORY"
code5_len: .data 10
//=============================================================================
//============================ UTILITY FUNCTIONS ==============================
//=============================================================================
// Loads our keyboard interrupt handler into the appropriate part of the
// interrupt vector. It does that by using a builtin integer offset from
// the beginning of the vector, as denoted by `IV$...` Only called once.
setup_interrupts:
      load  r1, interrupt_vector
      setsr r1, $intvec
      load  r2, keyboard_interrupt_handler
      store r2, [r1 + iv$keybd]
      load  r1, 0
      setfl r1, $ip
      ret

// The process of clearing a character after backspace has been pressed.
// We move the cursor back a column, but the old character is still there.
// So we move back, print a space, and move back again.
// void process_backspace() {
//       if (readptr == writeptr) return;
//       else {
//             int tmp = (writeptr - 1) % 512;
//             if (buf[tmp] == '\n')
//                   return;
//             else {
//                   putchar('\b');
//                   putchar(' ');
//                   putchar('\b');
//                   writeptr = tmp;
//             }
//       }
//       return;
// }
process_backspace:
      load  r1, [writeptr]
      comp  r1, [readptr]
      jcond neq, pb_elif
      ret
pb_elif:
      dec   r1
      mod   r1, 512
      comp  r1, '\n'
      jcond neq, pb_else
      ret
pb_else:
      type  '\b'
      type  ' '
      type  '\b'
      store r1, [writeptr]
      ret

// What happens after pressing CTRL+U. Simply echoing the chracter does not
// clear the line like a backspace, so we have to clear every character
// that's been in the line before. We do this by calling backspace
// for the length of the current line.
// void process_clear_line() {
//       while (true) {
//             if (tmp == writeptr) return;
//             else if (buf[(writeptr - 1) % 512]) return;
//             process_backspace();
//       }
// }
// Implementation is an optimized version that is highly dependent on
// process_backspace() having the same if-branches and comparisons as
// the pseudo-code above.
process_clear_line:
      load  r1, 0
      setfl r1, $z
pcl_loop:
      jcond neq, pcl_done
      call  process_backspace
      jump  pcl_loop
pcl_done:
      ret

// Used to print a 32-bit number (positive or negative).
// Taken from assignment 1, slightly modified to deal with negatives.
printint:                     // void print(int N) {
      push    FP
      load    FP, SP
      sub     SP, 2           // int Q, R;

      load    R1, [FP+2]      // Q = N / 10;
      jpos    R1, pr_is_pos   // if (N < 0) {
      type    '-'             // putchar('-');
      mul     R1, -1          // N *= -1; }
      store   R1, [FP+2]
pr_is_pos:
      div     R1, 10
      store   R1, [FP-1]
      load    R2, R1          // R = N - Q * 10;
      mul     R2, 10
      rsub    R2, [FP+2]
      store   R2, [FP-2]
      compz   R1              // if (Q > 0) print(Q);
      jcond   LEQ, pr_leq
      push    R1
      call    printint
pr_leq:
      load    R2, [FP-2]      // printf("%d", R);
      add     R2, '0'
      type    R2
      load    SP, FP          // }
      pop     FP
      ret

// When we call a PERI instruction, the first argument holds a 0 or a negative
// error code, also shown with an active ERR flag. For $TERMINC, we detect
// this error code, print out the error message with $TERMOUT (whose own
// error codes we ignore), and then halt the program.
// Assume that the PERI error register is R11 (reserve this for PERI out).
keyboard_input_error:        // void keyboard_input_error() {
      comp  r11, -2          //     if (ERROR_REGISTER == -2) printf(CODE2);
      jcond neq, kie_else
      load  r1, code2_len
      load  r2, control_out
      load  r3, code2
      store r1, [r2 + 1]
      store r3, [r2 + 2]
      peri  r0, r2
      jump  kie_halt
kie_else:
      load  r1, code5_len    //     else printf(CODE5);
      load  r2, control_out
      load  r3, code5
      store r1, [r2 + 1]
      store r3, [r2 + 2]
      peri  r0, r2
      jump  kie_halt
kie_halt:
      type  '\n'             //     putchar('\n');
      halt                   //     exit(1); }
//=============================================================================
//============================ INTERRUPT HANDLER ==============================
//=============================================================================
// The main part of the program. This handler is called asynchronously from
// the normal flow of the program. Whenever a key is pressed, this function
// takes over and uses a new set of registers that are not visible to normal
// execution. To handle this register bookkeeping, it is important to exit
// with `iret`.
//
// At a high level, we want to get the input character with the PERI command
// from the hardware input buffer, pack it in the buffer without consuming
// an entire word per character, and then correctly echo the input.
keyboard_interrupt_handler:
      load  r1, control_in             // Get and temporarily store the char.
      load  r2, character_scratch
      store r2, [r1 + 2]
      peri  r11, r1                    // Use R11 as convention to store code.
      jcond err, keyboard_input_error  // Halt on error.
      load  r0, [character_scratch]
case_backspace:                        // Decide how to echo the keypress.
      comp  r0, 8                      // ASCII Backspace
      jcond neq, case_del
      call  process_backspace
      jump  kih_done
case_del:                              // My terminal does not do backspaces
      comp  r0, 0x7f                   // correctly, instead opting to
      jcond neq, case_nb               // send some delete character.
      call  process_backspace          // Let's humor it.
      jump  kih_done
case_nb:                               // ASCII ^U
      comp  r0, 21
      jcond neq, case_newline
      call  process_clear_line
      jump  kih_done
case_newline:                          // ASCII Enter
      comp  r0, '\n'
      jcond neq, case_nctrlu
      type  '\n'
      load  r1, 0                      // Reset the character pointer.
      load  r0, 0                      // Add a null-terminator so we know
      load  r3, [character_pointer]    // what's up.
      stch  r3, character_buffer
      store r1, [character_pointer]
      store r1, [character_read_pointer]
      jump  kih_done
case_nctrlu:
      comp  r0, 32                     // Check to see if code is in range
      jcond lss, kih_done              // [32, 126], the printable range.
      comp  r0, 126
      jcond gtr, kih_done
      load  r0, [character_scratch]    // Store in less volatile,
      load  r3, [character_pointer]    // more compressed location.
      stch  r3, character_buffer
      inc   [character_pointer]
      load  r1, [character_scratch]    // Reload character scratch and type.
      type  r1
      jump  kih_done
kih_done:
      iret
//=============================================================================
//============================= USER FUNCTIONS ================================
//=============================================================================
// Gets the next character in the software buffer without waiting, if there
// is a full line available, otherwise -1. The heuristic we use to see if
// the character pointer is at the front and the current character is not null.
// That means the enter button was pressed, reseting the position of the
// character pointer.
//
// Rather than allocating memory for local variables and returns (which is
// complexity we don't need too badly), we use registers and hope for the best.
getchar_nw:                               // char getchar_nw() {
      load  r1, -1                        //     char c = -1;
      load  r2, [character_pointer]       //     if (CHARACTER_POINTER == 0) {
      compz r2
      jcond neq, gcnw_else
      load  r2, [character_read_pointer]  //         if (CHR_BUFF[CHR_READ_PTR] != 0) {
      ldch  r2, character_buffer
      compz r2
      jcond eql, gcnw_else
      load  r1, r2                        //             c = CHR_BUFF[CHR_READ_PTR];
      inc   [character_read_pointer]      //             CHR_READ_PTR++; } }
gcnw_else:
      store r1, r12                      //     return c; }
      ret

// This is the blocking version of getchar(). It just pauses until something
// exciting happens.
getchar:                      // char getchar() {
      call  getchar_nw        //     while ((char c = getchar_nw()) < 0)
      jpos  r12, gc_loop_end
      pause                   //         sleep(50);
      jump  getchar
gc_loop_end:
      ret                     //     return c; }

// Puts a taken character back into the front of the buffer.
// Assume we're not at the front of the buffer since we're putting back.
backchar:                                // void backchar(char c) {
      dec   [character_read_pointer]     //     CHR_READ_PTR--;
      load  r1, [character_read_pointer]
      load  r0, r12                      //     CHARACTER_BUFF[CHR_READ_PTR] = c;
      stch  r1, character_buffer
      ret                                //     return; }

// Uses getchar() and by extension getchar_nw(). Converts an ASCII
// integer to a signed 32-bit integer. Acts like atoi().
// Uses higher-numbered registers to avoid tripping. This is not ideal.
getint:                      // int getint() {
      load  r5, 1            //     int mul = 1;
      call  getchar
      load  r6, r12          //     int sum = getchar();
      comp  r6, '-'          //     if (sum == '-') {
      jcond neq, gi_loop_pre
      load  r5, -1           //         mul = -1;
      load  r6, '0'          //         sum = '0'; }
gi_loop_pre:
      sub   r6, '0'          //     sum -= '0'
      load  r7, -1           //     int i = -1;
gi_loop:
      call  getchar_nw       //     while ((i = getchar_nw()-'0') > 0 && i <=9) {
      load  r7, r12
      sub   r7, '0'
      jneg  r7, gi_loop_end
      comp  r7, 9
      jcond gtr, gi_loop_end
      mul   r6, 10           //         sum *= 10;
      add   r6, r7           //         sum += i; }
      jump  gi_loop
gi_loop_end:
      mul   r6, r5           //     return sum * mul; }
      load  r12, r6
      ret
//=============================================================================
//================================== MAIN =====================================
//=============================================================================
main:
      call  setup_interrupts
      call  test_program
      halt
//=============================================================================
//=============================== TEST PROGRAM ================================
//=============================================================================
// This is a simple program that demonstrates all of the user program funs.
// getint() depends on getchar() depends on getchar_nw() depends on kbhand
test_program:          // void test_program() {
      call  getint     //     printf("%d\n", getint());
      push  r12
      call  printint
      type  '\n'
      inc   sp

      load  r12, '2'   //     backchar('2');
      call  backchar   //     printf("%d\n", getint());
      call  getint
      push  r12
      call  printint
      type  '\n'
      inc   sp

      ret              //       return; }
