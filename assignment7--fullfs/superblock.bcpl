import "io"
import "fsutils"
import "conversion"

export {
    create_superblock,
    sb_blocknum,
    sb_name_words,
    sb_magic, sb_magic_value,
    df
}

// Constants for superblock
manifest {
    // Location of superblock on disc. NB: blocks are 0-indexed.
    sb_blocknum = 0,
    // (1) Magic number to identify filesystem
    sb_magic = 0, sb_magic_value = 0x3434,
    // (2) Name of the disc (three words => 11 chars)
    sb_name = 1, sb_name_words = 3,
    // (3) Disc capacities (two fields share same word)
    sb_size = 4,
    sb_total_size = selector 31 : 16, sb_free_size = selector 16 : 0,
    // (4) Location of root directory
    sb_root = 5,
    // (5) Location of start (that is, the bottom) of the free stack
    sb_freelist = 6
}

let set_magic(buf) be
    buf ! sb_magic := sb_magic_value

let set_name(buf, str) be
    strncpy(buf+sb_name, str, sb_name_words);

let set_total_capacity(buf, size) be
    sb_total_size from buf ! sb_size := size
let get_total_capacity(buf) be
    resultis sb_total_size from buf ! sb_size
let set_free_capacity(buf, size) be
    sb_free_size from buf ! sb_size := size
let get_free_capacity(buf) be
    resultis sb_free_size from buf ! sb_size

let set_root_location(buf, addr) be
    buf ! sb_root := addr
let get_root_location(buf) be
    resultis buf ! sb_root

let create_superblock(unit_number, name) be {
    let buf = vec words_per_block;
    // TODO: check if lt 0 and perror()
    let disc_size = get_physical_disc_size(unit_number);

    set_magic(buf);
    set_name(buf, name);
    set_total_capacity(buf, disc_size);
    set_free_capacity(buf, disc_size);

    // TODO: root & free calculations

    // Finally, write out
    write_block(unit_number, sb_blocknum, buf);
}

// TODO: implement
let df() be {}
