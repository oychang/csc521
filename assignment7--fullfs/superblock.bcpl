import "io"
import "fsutils"
import "conversion"
import "nodes"

export {
    create_superblock,
    sb_blocknum,
    sb_name_words,
    sb_magic, sb_magic_value,
    df
}

// Constants for superblock
manifest {
    // Location of superblock on disc. NB: blocks are 0-indexed.
    sb_blocknum = 0,
    // (1) Magic number to identify filesystem
    sb_magic = 0, sb_magic_value = 0x34343434,
    // (2) Name of the disc (three words => 11 chars)
    sb_name = sb_magic + 1, sb_name_words = 3,
    // (3) Disc unformatted capacity
    sb_size = sb_name + sb_name_words,
    // (4) Disc used size
    sb_used_size = sb_size + 1,
    // (5) Location of root directory
    sb_root = sb_used_size + 1,
    // (6) Location of start of the free stack
    sb_freelist = sb_root + 1
}


let read_superblock(unit_number, buf) be
    read_block(unit_number, sb_blocknum, buf);
let write_superblock(unit_number, buf) be
    write_block(unit_number, sb_blocknum, buf);

let set_magic(buf) be
    buf ! sb_magic := sb_magic_value

let set_name(buf, str) be
    strncpy(buf+sb_name, str, sb_name_words)
let get_name(dest, buf) be
    strncpy(dest, buf+sb_name, sb_name_words)

let set_total_capacity(buf, size) be
    buf ! sb_size := size
let get_total_capacity(buf) be
    resultis buf ! sb_size
let set_used_capacity(buf, size) be
    buf ! sb_used_size := size
let get_used_capacity(buf) be
    resultis buf ! sb_used_size

let set_root_location(buf, addr) be
    buf ! sb_root := addr
let get_root_location(buf) be
    resultis buf ! sb_root

// Returns the index of the word at the head of the free list.
// This word (and the block it refers to) is currently not being used.
let get_head_pointer(sb) be {
    let free_capacity = get_total_capacity(sb) - get_used_capacity(sb);
    resultis blocks_to_words(sb_freelist) + free_capacity;
}

// Get the block a word is in.
let get_words_block(word_number) be
    resultis (word_number / words_per_block)
// Get a word's position within a block
let get_words_position(word_number) be
    resultis (word_number rem words_per_block)

let fl_push(unit_number, block_to_push) be {
    let sb = vec words_per_block;
    let fb = vec words_per_block;
    let head, head_block, head_word, used_cap;
    read_superblock(unit_number, sb);

    head := get_head_pointer(sb);          // Index of word at head of free list
    head_block := get_words_block(head);   // Block head belongs in
    head_word := get_words_position(head); // Word of that block that head is
    used_cap := get_used_capacity(sb) - 1; // Number of used blocks

    // head = 6848, head_block = 876544, head_word = -1
    // used capacity = 47
    out("head = %d, head_block = %d, head_word = %d\n", head, head_block, head_word);
    out("used capacity = %d\n", used_cap);
    return;

    set_used_capacity(sb, used_cap);
    write_superblock(unit_number, sb);

    read_block(unit_number, head_block, fb);
    fb ! (head_word + 1) := block_to_push;
    write_block(unit_number, head_block, fb);

    // Number of blocks pushed
    // TODO: support pushing more than one at a time
    resultis 1;
}

let fl_push_initial(unit_number) be {
    let sb = vec words_per_block;
    let fb = vec words_per_block;
    let eb = vec words_per_block; // EDIT
    let h_index, h_block, h_word, used_cap, current_word, root_word;
    read_superblock(unit_number, sb);

    h_index := sb_freelist; // Index of word at head of free list
    h_block := get_words_block(h_index);   // Block head belongs in
    h_word := get_words_position(h_index);

    current_word := get_total_capacity(sb);
    root_word := get_root_location(sb);

    out("current_word = %d, root_word = %d\n", current_word, root_word);
    out("h_index = %d, h_block = %d, h_word = %d\n", h_index, h_block, h_word);

    read_block(unit_number, h_block, fb);

    // h_index = 7, h_block = 896, h_word = 0
    while current_word > root_word do {
//        read_block(unit_number, h_block, fb); // read head block
        fb ! h_word := current_word;
        if (h_word = (words_per_block -1)) then {
	    write_block(unit_number, h_block, fb);
	    h_block +:= 1;
            read_block(unit_number, h_block, fb);
        }
	if (current_word rem 500 = 0) then {
            out("Pushed 500 words! : ");
            out("%d\n", fb ! h_word);
            read_block(unit_number, 0, eb);
	    out("Did we put something at the bottom of stack : %d\n", eb ! 7);
        }
        h_index +:= 1;
        h_word := get_words_position(h_index);
        current_word -:= 1;

//        for x = h_word to (words_per_block - 1) do { // EDIT: 7 through 127
//            fb ! h_word := current_word;
//            h_index +:= 1;
//            h_word := get_words_position(h_index); // Word of block that head is
//            current_word -:= 1;
//        }

    }
    h_index -:= 1;
    write_block(unit_number, h_block, fb);

    // h_index = 5985, h_block = 942, h_word = -1
    out("sb_size = %d, sb_used_size = %d, sb_root = %d, sb_freelist = %d\n", sb_size, sb_used_size, sb_root, sb_freelist);
    out("sb_size = %d, sb_used_size = %d, sb_root = %d\n", get_total_capacity(sb), get_used_capacity (sb), get_root_location(sb));
    out("h_index = %d, h_block = %d, h_word = %d\n", h_index, h_block, h_word);
    return;
}

//let fl_pop(buf, n_blocks) be {
//    get stack head
//        get number used blocks
//        word at head of stack :=
//            blocks_to_words(sb_root) - number used blocks
//
//    let i = stack_head
//    from n_blocks to 0 do
//        buf.append(freelist[i])
//        i++
//}

let create_superblock(unit_number, name) be {
    let buf = vec words_per_block, disc_size;
    let super_block_blocks;

    // fixme: check if lt 0 and perror()
    disc_size := get_physical_disc_size(unit_number);
    super_block_blocks := words_to_blocks(disc_size + sb_freelist);

    set_magic(buf);
    set_name(buf, name);
    set_total_capacity(buf, disc_size);
    // Not equal to zero because superblock takes up space
    set_used_capacity(buf, super_block_blocks + 1);

    // Use first block after end of super block store the root directory
    // XXX: this is not accurate since freelist presumed to be usable space
    set_root_location(buf, super_block_blocks + 1);

    // Finally, write out
    // fixme: check if lt 0 and perror()
    write_block(unit_number, sb_blocknum, buf);

    // Push all chunks onto the free stack
    fl_push_initial(unit_number);
    // TODO: create root directory
}

let df() be {
    let buf = vec words_per_block;
    let str = vec sb_name_words;
    let disc_no = 1;
    let retval = 0;

    {
        retval := get_physical_disc_size(disc_no);
        if retval <= 0 then break;

        read_block(disc_no, sb_blocknum, buf);
        // TODO: do not show if disc unformatted
        get_name(str, buf);
        out("disc %d: %s\n", disc_no, str);
        out("total size: %d blocks    ", get_total_capacity(buf));
        out("used size: %d blocks    ", get_used_capacity(buf));
        out("root location: block %d\n\n", get_root_location(buf));

        disc_no +:= 1;
    } repeat;
}
