import "io"
import "fsutils"
import "conversion"

export {
    create_superblock,
    sb_blocknum,
    sb_name_words,
    sb_magic, sb_magic_value,
    df
}

// Constants for superblock
manifest {
    // Location of superblock on disc. NB: blocks are 0-indexed.
    sb_blocknum = 0,
    // (1) Magic number to identify filesystem
    sb_magic = 0, sb_magic_value = 0x34343434,
    // (2) Name of the disc (three words => 11 chars)
    sb_name = sb_magic + 1, sb_name_words = 3,
    // (3) Disc unformatted capacity
    sb_size = sb_name + sb_name_words,
    // (4) Disc used size
    sb_used_size = sb_size + 1,
    // (5) Location of root directory
    sb_root = sb_used_size + 1,
    // (6) Location of start of the free stack
    sb_freelist = sb_root + 1
}


let read_superblock(unit_number, buf) be {
    read_block(unit_number, sb_blocknum, buf);
}

let set_magic(buf) be
    buf ! sb_magic := sb_magic_value

let set_name(buf, str) be
    strncpy(buf+sb_name, str, sb_name_words)
let get_name(dest, buf) be
    strncpy(dest, buf+sb_name, sb_name_words)

let set_total_capacity(buf, size) be
    buf ! sb_size := size
let get_total_capacity(buf) be
    resultis buf ! sb_size
let set_used_capacity(buf, size) be
    buf ! sb_used_size := size
let get_used_capacity(buf) be
    resultis buf ! sb_used_size

let set_root_location(buf, addr) be
    buf ! sb_root := addr
let get_root_location(buf) be
    resultis buf ! sb_root

// Suppose we can get more than one for both of these.

// block_numbers is a vector of block numbers to be pushed (in reverse)
// n_blocks is the number of (word large) elements in block_numbers
let fl_push(disc_no, block_numbers, n_blocks) be {
    let stack_head;
    let sb = vec words_per_block;
    read_superblock(disc_no, sb);

    stack_head := blocks_to_words(get_root_location(sb)) - get_used_capacity(sb) - 1;



        //freelist[i] := block_numbers[j]
        //:= block_numbers ! j;
    for i = n_blocks to 0 by (-1 * words_per_block) do {
        for j = i to 0 do {

        }

        stack_head -:= 1;
    }



    set_used_capacity(sb, get_used_capacity(sb) + n_blocks);
    write_block(disc_no, sb_blocknum, sb)
}

//let fl_pop(buf, n_blocks) be {
//    get stack head
//        get number used blocks
//        word at head of stack :=
//            blocks_to_words(sb_root) - number used blocks
//
//    let i = stack_head
//    from n_blocks to 0 do
//        buf.append(freelist[i])
//        i++
//}

let create_superblock(unit_number, name) be {
    let buf = vec words_per_block, disc_size;
    let super_block_blocks;

    // fixme: check if lt 0 and perror()
    disc_size := get_physical_disc_size(unit_number);
    super_block_blocks := words_to_blocks(disc_size + sb_freelist);

    set_magic(buf);
    set_name(buf, name);
    set_total_capacity(buf, disc_size);
    set_used_capacity(buf, 0);

    // Use first block after end of super block store the root directory
    // XXX: this is not accurate since freelist presumed to be usable space
    set_root_location(buf, super_block_blocks + 1);

    // Finally, write out
    // fixme: check if lt 0 and perror()
    write_block(unit_number, sb_blocknum, buf);

    // Push all chunks onto the free stack
    // TODO: implement
    fl_push(unit_number);
    //fl_push();
    // TODO: create root directory
}

let df() be {
    let buf = vec words_per_block;
    let str = vec sb_name_words;
    let disc_no = 1;
    let retval = 0;

    {
        retval := get_physical_disc_size(disc_no);
        if retval <= 0 then break;

        read_block(disc_no, sb_blocknum, buf);
        // TODO: do not show if disc unformatted
        get_name(str, buf);
        out("disc %d: %s\n", disc_no, str);
        out("total size: %d blocks    ", get_total_capacity(buf));
        out("used size: %d blocks    ", get_used_capacity(buf));
        out("root location: block %d\n\n", get_root_location(buf));

        disc_no +:= 1;
    } repeat;
}

